I"*A<!-- Description Guidelines

Please note:
Use the full links to reference other files or images! Relative links will not work under our theme settings settings.
-->

<!-- please choose the appropriate batch and delete/comment the others  -->
<p><img src="https://img.shields.io/badge/Status-Production-brightgreen.svg" alt="prod" /></p>

<h1 id="conflict-management-"><strong>Conflict Management</strong> <!-- make sure spelling is consistent with other sources and within this document --></h1>

<h2 id="introduction">Introduction</h2>
<!-- 2 sentences: what does it do and how -->
<p>The Open Integration Hub Conflict Management (CFM) is an optional module that can be included in an adapter. It automatically resolves potential conflicts according to a set of adapter-developer-defined rules. The CFM’s implementation is generic and class-based, allowing an adapter developer to create and add new rules specific to an application’s requirements.</p>

<!--[API Reference](http://data-hub.openintegrationhub.com/api-docs){: .btn .fs-5 .mb-4 .mb-md-0 }-->
<p><a href="https://www.npmjs.com/package/@wice-devs/cfm" class="btn fs-5 mb-4 mb-md-0">npm package</a>
<a href="https://github.com/openintegrationhub/openintegrationhub/tree/master/lib/cfm" class="btn fs-5 mb-4 mb-md-0">Service File</a></p>

<h2 id="how-it-works">How it works</h2>
<!-- describe core functionalities and underlying concepts in more detail -->

<p>Within a connector flow, the CFM can be included in an adapter that connects to a target application it pushes data to. To do this, an adapter developer can include the CFM moduel into their adapter, set it up as desired, and then use it to process potential conflicts.</p>

<p>To use the CFM, the adapter needs to pass it two objects: First, the incoming object from the connecting flow, and secondly the corresponding object from the target application’s data store, if such an object exists. If the second object can not be uniquely identified, the adapter can also supply a best guess for a match, and configure the CFM to handle this case. These objects must both be converted to JSON before passing them on to the CFM. The CFM has no requirements to the object schema, only both objects use the same schema. After resolution is complete, the CFM will return a reconciled object in the same schema, which the adapter can then pass on to the target applications.</p>

<p>The CFM operates on a set of <em>Rules</em>. Each rule is associated with a given number of object keys to which it applies. During conflict resolution, both the source and target values of that key are passed on to their associated <em>Rule</em>, which attempts to reconcile any differences according to a set of internal <em>Resolvers</em>, and returns the reconciled value.</p>

<p>Both sets of <em>Rules</em> and <em>Resolvers</em> are expandable. Should the included default selection be unsuitable for a particular application, the adapter developer can add their own <em>Rules</em> and/or <em>Resolvers</em> in place and use them right away.</p>

<p align="center">
  <img src="https://raw.githubusercontent.com/openintegrationhub/openintegrationhub/master/lib/cfm/assets/CFM.png" alt="OIH-CFM workflow" />
</p>

<h2 id="technical-description">Technical description</h2>
<p>The CFM offers three classes, which each expose a number of functions for developer to customize its behaviour.</p>

<h3 id="cfm">CFM</h3>
<p>The CFM itself is the top-level module. It is instantiated during the initialisation of an adapter, containing all configuration data. During actual data transfer, it can then be called to handle conflict management. It exposes these functions:</p>

<h4 id="setrulesrulename-key-key2"><code class="language-plaintext highlighter-rouge">setRules({ruleName: [key, key2]})</code></h4>
<p>Accepts an object with the name of used rules as keys, and arrays of strings as values.</p>

<p>The primary function of CFM configuration. This maps a particular rule to a list of key names. Each rule can be set only once, duplicate assignments within the same function call are rejected. Keys that have not been assigned to a rule automatically use a default rule.</p>

<h4 id="setdefaultrulesrulename-somename"><code class="language-plaintext highlighter-rouge">setDefaultRules(ruleName: somename})</code></h4>
<p>Accepts an object with the name of used rules as keys and an arbitrary name as value.</p>

<p>Each key can only be set once, duplicate assignments within the same function call are rejected.</p>

<p>This function adds a particular rule to a list of default rules. Default rules are only executed if there is key for which no other rule is specified.</p>

<p>The default configuration is the rule <em>onlyOverwriteEmpty</em> which will only add values to the target if the target does not have the key or the value is empty.</p>

<p>The <em>default rules can be deactivated</em> by calling with an empty object. Ie.: <code class="language-plaintext highlighter-rouge">setDefaultRules({});</code></p>

<h4 id="setglobalrulesrulename-somename"><code class="language-plaintext highlighter-rouge">setGlobalRules({ruleName: somename})</code></h4>
<p>Accepts an object with the name of used rules as keys and an arbitrary name as value.</p>

<p>The primary function of global CFM configuration. This adds a particular rule to a list of global rules. Each key can only be set once, duplicate assignments within the same function call are rejected.</p>

<h4 id="addcustomrulename-resolver"><code class="language-plaintext highlighter-rouge">addCustomRule(name, [resolver])</code></h4>
<p>Accepts a string as name for the rule, and an ordered array of resolvers to be used, referenced by name. Rule name cannot be a duplicate, all assigned resolvers must exist.</p>

<p>This allows the developer to add a new rule, using a custom set of resolvers. Resolvers are applied in the order they are entered in the array. Check the example Rules for further information.</p>

<h4 id="addcustomresolvername-function"><code class="language-plaintext highlighter-rouge">addCustomResolver(name, function)</code></h4>
<p>Accepts a string as a name for the resolver, and a javascript function as its function. Resolver name cannot be duplicate. The function must accept exactly two arguments, and return either a value of the same type, or <code class="language-plaintext highlighter-rouge">false</code> in case resolution is impossible. See the example Resolvers for further information.</p>

<h4 id="resolveincomingobject-targetobject"><code class="language-plaintext highlighter-rouge">resolve(incomingObject, targetObject)</code></h4>
<p>Accepts two JSON objects, which must use the same schema. Returns a JSON object of the same schema, or <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>The core function of the CFM. This applies the rules set during configuration to both objects and creates a new one with all conflicts resolved. If reconciliation fails or the conflicts are irresolvable, it instead returns <code class="language-plaintext highlighter-rouge">false</code>.</p>

<h3 id="rule">Rule</h3>
<p>Rules are the core building block of the CFM. A Rule is essentially a sequence of predefined functions (called <em>Resolvers</em>) that receive two potentially conflicting data values (which can be in any Javascript format: String, Number, Object, Array, etc.) and attempt to resolve this conflict. If successful, the rule will return the new reconciled value.</p>

<p>The primary consideration when creating a rule is the selection and order of Resolvers. Resolvers are applied in the specific order they were added to the Rule. The first Resolver that produces a resolution “wins”, and any further Resolvers are no longer used.</p>

<p>Rules can be created and applied through the functions exposed by the CFM. The adapter should not manipulate rules directly.</p>

<h3 id="predefined-rules">predefined rules</h3>

<p><code class="language-plaintext highlighter-rouge">copyNew</code>: Is copying data from incoming to target if incoming is not empty.</p>

<p><code class="language-plaintext highlighter-rouge">rejectEmpty</code>: Is copying data from incoming to target event if incoming is empty.</p>

<p><code class="language-plaintext highlighter-rouge">onlyOverwriteEmpty</code>: Only copies data from incoming to target if data in target is undefined or empty.</p>

<p><code class="language-plaintext highlighter-rouge">ifUpdate</code>: Is copying data from incoming to target if all keys exists in both objects and at least one value of incoming is not empty.</p>

<p><code class="language-plaintext highlighter-rouge">uniqArray</code>: Takes two array values as input and compares all elements to each other and returns an merged array without duplicates.</p>

<h3 id="predefined-global-rules">predefined global rules</h3>

<p><code class="language-plaintext highlighter-rouge">ResolverSkipDuplicateEntry</code>: Compares incoming data to target data and makes CFM return <code class="language-plaintext highlighter-rouge">{}</code> if it is an exact duplicate.</p>

<h3 id="resolver">Resolver</h3>
<p>Resolvers are the lowest-level component of the CFM. They contain a single arbitrary function that takes two data values and attempt to find a reconciliation for them. If successful, the reconciled value is returned as an object in the following form: <code class="language-plaintext highlighter-rouge">{value:returnedData}</code>.</p>

<p>If no reconciliation can be found, they should instead return <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>New Resolvers can be created and assigned through functions of the CFM, and are executed automatically by the Rules they are assigned to. The adapter should not manipulate Resolvers directly.</p>

<p>Resolvers used in global rules should return an empty object “{}” if an entry is supposed to be skipped.</p>

<h2 id="examples">Examples</h2>
<p>Creating two custom resolvers, for handling a particular type of object</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">CFM</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">@wice-devs/cfm</span><span class="dl">'</span><span class="p">)</span>

<span class="c1">// This resolver checks whether a certain field in the incoming object matches the value of the target object</span>
<span class="c1">// If it does not, the reference has been changed, any data of the target object is outdated, and only the incoming data is used</span>
<span class="c1">// If it does match, this is not the case, the resolver returns false, and the issue is passed on to the next resolver in line.</span>
<span class="nx">CFM</span><span class="p">.</span><span class="nx">addCustomResolver</span><span class="p">(</span><span class="dl">'</span><span class="s1">overwriteIfNew</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">incoming</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">incoming</span><span class="p">.</span><span class="nx">lastName</span> <span class="o">!==</span> <span class="nx">target</span><span class="p">.</span><span class="nx">lastName</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="na">value</span><span class="p">:</span> <span class="nx">incoming</span><span class="p">}</span>
  <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span>
<span class="p">})</span>

<span class="c1">// This resolver performs a soft merge, where only empty fields of the target object</span>
<span class="c1">// are filled with values from the incoming object</span>
<span class="nx">CFM</span><span class="p">.</span><span class="nx">addCustomResolver</span><span class="p">(</span><span class="dl">'</span><span class="s1">fillOnlyEmptyFields</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">incoming</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">resolvedObject</span> <span class="o">=</span> <span class="nx">target</span><span class="p">;</span>

  <span class="k">for</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">incoming</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">resolvedObject</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">incoming</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">resolvedObject</span><span class="p">;</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Creating a custom rule, using the resolvers created earlier:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This rule applies first the "overwriteIfNew" resolver, then the "fillOnlyEmptyFields" one</span>
<span class="c1">// If the incoming object lacks the required keys, it is discarded entirely by rejectIfIncomplete</span>
<span class="c1">// If it does not, it is passed on and next handled by the fillOnlyEmptyFields resolver, which enriches the target object without overwriting existing data</span>
<span class="nx">CFM</span><span class="p">.</span><span class="nx">addCustomRule</span><span class="p">(</span><span class="dl">'</span><span class="s1">enrichPersonData</span><span class="dl">'</span><span class="p">,</span> <span class="p">[</span><span class="dl">'</span><span class="s1">overwriteIfNew</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">fillOnlyEmptyFields</span><span class="dl">'</span><span class="p">])</span>
</code></pre></div></div>

<p>Finally, assigning the rule to the appropriate object keys:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">CFM</span><span class="p">.</span><span class="nx">setRules</span><span class="p">({</span><span class="dl">'</span><span class="s1">enrichPersonData</span><span class="dl">'</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">recipient</span><span class="dl">'</span><span class="p">]})</span>
</code></pre></div></div>

<h2 id="local-installationdevelopment">Local installation/development</h2>

<p>Do <code class="language-plaintext highlighter-rouge">npm install --save @wice-devs/cfm</code> and implement the following code in your adapter:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">CFM</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">../index</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">cfm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CFM</span><span class="p">();</span>
<span class="c1">// add your CFM Config here like explained above or see test folder for examples</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">cfm</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">incomingData</span><span class="p">,</span> <span class="nx">localData</span><span class="p">);</span>
</code></pre></div></div>

<p>Where localData has to be provided from your system and incomingData is the data passed from the transformer.</p>

<p>the result will be an newObject based on the applied resolvers.</p>

<p>If the <em>result object is an empty object</em> then this means the incomingData should be discarded. For example if a global resolver identifies it as an exact copy of the localData.</p>
:ET